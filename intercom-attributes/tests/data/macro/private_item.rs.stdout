#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::rust_2015::*;
#[macro_use]
extern crate std;
extern crate intercom;
use intercom::*;

trait IFoo {
    fn trait_method(&self);
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __IFoo_trait_method_Automation<I, S>(
    self_vtable: intercom::raw::RawComPtr,
) -> ()
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::AutomationTypeSystem>
        + intercom::attributes::ComClass
        + IFoo,
{
    let offset = <S as intercom::attributes::ComClassInterface<
        I,
        intercom::type_system::AutomationTypeSystem,
    >>::offset();
    let self_combox = (self_vtable as usize - offset) as *mut intercom::ComBoxData<S>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<S>()),
                    ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                ],
            ),
        )
    });
    let self_struct = &**self_combox;
    let __result = self_struct.trait_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<S>()),
                    ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                ],
            ),
        )
    });
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
struct __IFooAutomationVTable {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub trait_method: unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::clone::Clone for __IFooAutomationVTable {
    #[inline]
    fn clone(&self) -> __IFooAutomationVTable {
        {
            let _: ::core::clone::AssertParamIsClone<
                <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable,
            >;
            let _: ::core::clone::AssertParamIsClone<
                unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
            >;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::marker::Copy for __IFooAutomationVTable {}
#[allow(unused)]
impl<I, S>
    intercom::attributes::ComInterfaceVTableFor<I, S, intercom::type_system::AutomationTypeSystem>
    for dyn IFoo
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::AutomationTypeSystem>
        + intercom::attributes::ComClass
        + IFoo,
{
    const VTABLE: __IFooAutomationVTable = __IFooAutomationVTable {
        __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVTableFor<
            I,
            S,
            intercom::type_system::AutomationTypeSystem,
        >>::VTABLE,
        trait_method: __IFoo_trait_method_Automation::<I, S>,
    };
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>
    for dyn IFoo
{
    type VTable = __IFooAutomationVTable;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __IFoo_trait_method_Raw<I, S>(self_vtable: intercom::raw::RawComPtr) -> ()
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::RawTypeSystem>
        + intercom::attributes::ComClass
        + IFoo,
{
    let offset = <S as intercom::attributes::ComClassInterface<
        I,
        intercom::type_system::RawTypeSystem,
    >>::offset();
    let self_combox = (self_vtable as usize - offset) as *mut intercom::ComBoxData<S>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<S>()),
                    ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                ],
            ),
        )
    });
    let self_struct = &**self_combox;
    let __result = self_struct.trait_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<S>()),
                    ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                ],
            ),
        )
    });
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
struct __IFooRawVTable {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
    pub trait_method: unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::clone::Clone for __IFooRawVTable {
    #[inline]
    fn clone(&self) -> __IFooRawVTable {
        {
            let _: ::core::clone::AssertParamIsClone<
                <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::RawTypeSystem,
                >>::VTable,
            >;
            let _: ::core::clone::AssertParamIsClone<
                unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
            >;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::marker::Copy for __IFooRawVTable {}
#[allow(unused)]
impl<I, S> intercom::attributes::ComInterfaceVTableFor<I, S, intercom::type_system::RawTypeSystem>
    for dyn IFoo
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::RawTypeSystem>
        + intercom::attributes::ComClass
        + IFoo,
{
    const VTABLE: __IFooRawVTable = __IFooRawVTable {
        __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVTableFor<
            I,
            S,
            intercom::type_system::RawTypeSystem,
        >>::VTABLE,
        trait_method: __IFoo_trait_method_Raw::<I, S>,
    };
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem> for dyn IFoo {
    type VTable = __IFooRawVTable;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
        }
    }
}
#[allow(clippy::all)]
#[allow(unused_braces)]
impl<I: intercom::attributes::ComInterface + IFoo + ?Sized> IFoo for intercom::ComItf<I> {
    fn trait_method(&self) -> () {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", "] Calling ", "::"],
                    &[
                        ::core::fmt::ArgumentV1::new_pointer(&self),
                        ::core::fmt::ArgumentV1::new_display(&"IFoo"),
                        ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                    ],
                ),
            )
        });
        #[allow(unused_imports)]
        use intercom::ErrorValue;
        if let Some(comptr) =
            intercom::ComItf::ptr::<intercom::type_system::AutomationTypeSystem>(self)
        {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", with ", "] Calling ", "::", ", type system: "],
                        &[
                            ::core::fmt::ArgumentV1::new_pointer(&self),
                            ::core::fmt::ArgumentV1::new_pointer(&comptr.ptr),
                            ::core::fmt::ArgumentV1::new_display(&"IFoo"),
                            ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                            ::core::fmt::ArgumentV1::new_display(&"Automation"),
                        ],
                    ),
                )
            });
            #[allow(unused_imports)]
            let vtbl = comptr.ptr.as_ptr()
                as *const *const <dyn IFoo as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;

            #[allow(unused_unsafe)]
            unsafe {
                let __result = ((**vtbl).trait_method)(comptr.ptr.as_ptr());
                let __intercom_iid = intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                };

                #[allow(unused_braces)]
                return {};
            }
        }
        if let Some(comptr) = intercom::ComItf::ptr::<intercom::type_system::RawTypeSystem>(self) {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", with ", "] Calling ", "::", ", type system: "],
                        &[
                            ::core::fmt::ArgumentV1::new_pointer(&self),
                            ::core::fmt::ArgumentV1::new_pointer(&comptr.ptr),
                            ::core::fmt::ArgumentV1::new_display(&"IFoo"),
                            ::core::fmt::ArgumentV1::new_display(&"trait_method"),
                            ::core::fmt::ArgumentV1::new_display(&"Raw"),
                        ],
                    ),
                )
            });
            #[allow(unused_imports)]
            let vtbl = comptr.ptr.as_ptr()
                as *const *const <dyn IFoo as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::RawTypeSystem,
                >>::VTable;

            #[allow(unused_unsafe)]
            unsafe {
                let __result = ((**vtbl).trait_method)(comptr.ptr.as_ptr());
                let __intercom_iid = intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
                };

                #[allow(unused_braces)]
                return {};
            }
        }

        ::core::panicking::panic("internal error: entered unreachable code");
    }
}
impl intercom::attributes::ComInterface for dyn IFoo {
    type TSelf = dyn IFoo;
    #[doc = "Returns the IID of the requested interface."]
    fn iid_ts<TS: intercom::type_system::TypeSystem>() -> &'static intercom::IID
    where
        Self: intercom::attributes::ComInterfaceVariant<TS>,
    {
        <Self as intercom::attributes::ComInterfaceVariant<TS>>::iid()
    }
    fn iid(ts: intercom::type_system::TypeSystemName) -> Option<&'static intercom::IID> {
        match ts {
            intercom::type_system::TypeSystemName::Automation => {
                Some(<Self as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid())
            }
            intercom::type_system::TypeSystemName::Raw => {
                Some(<Self as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::RawTypeSystem,
                >>::iid())
            }
        }
    }
    fn deref(com_itf: &intercom::ComItf<dyn IFoo>) -> &(dyn IFoo + 'static) {
        com_itf
    }
}
impl intercom::type_system::ForeignType for dyn IFoo {
    #[doc = r" The name of the type."]
    fn type_name() -> &'static str {
        "IFoo"
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
impl intercom::attributes::ComInterfaceTypeInfo for dyn IFoo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let variants = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                    ts: intercom::type_system::TypeSystemName::Automation,
                    iid: intercom::GUID {
                        data1: 0u32,
                        data2: 0u16,
                        data3: 0u16,
                        data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                    },
                    methods: <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([intercom::ComBox::new(
                            intercom::typelib::Method {
                                name: "trait_method".into(),
                                return_type: intercom::typelib::Arg {
                                    name: "".into(),
                                    ty: "void".into(),
                                    indirection_level: 0,
                                    direction: intercom::typelib::Direction::Return,
                                },
                                parameters: ::alloc::vec::Vec::new(),
                            },
                        )]),
                    ),
                }),
                intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                    ts: intercom::type_system::TypeSystemName::Raw,
                    iid: intercom::GUID {
                        data1: 0u32,
                        data2: 0u16,
                        data3: 0u16,
                        data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
                    },
                    methods: <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([intercom::ComBox::new(
                            intercom::typelib::Method {
                                name: "trait_method".into(),
                                return_type: intercom::typelib::Arg {
                                    name: "".into(),
                                    ty: "void".into(),
                                    indirection_level: 0,
                                    direction: intercom::typelib::Direction::Return,
                                },
                                parameters: ::alloc::vec::Vec::new(),
                            },
                        )]),
                    ),
                }),
            ]),
        );
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([intercom::typelib::TypeInfo::Interface(
                intercom::ComBox::new(intercom::typelib::Interface {
                    name: "IFoo".into(),
                    variants,
                    options: intercom::typelib::InterfaceOptions {
                        class_impl_interface: false,
                        ..Default::default()
                    },
                }),
            )]),
        )
    }
}
struct Foo;
impl intercom::IUnknown for Foo {}
impl intercom::attributes::HasInterface<Foo> for Foo {}
#[allow(non_snake_case)]
impl intercom::attributes::ComClassInterface<Foo, intercom::type_system::AutomationTypeSystem>
    for Foo
{
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClassInterface<Foo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Raw as *const _ as usize }
    }
}
impl intercom::attributes::HasInterface<dyn IFoo> for Foo {}
#[allow(non_snake_case)]
impl intercom::attributes::ComClassInterface<dyn IFoo, intercom::type_system::AutomationTypeSystem>
    for Foo
{
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().IFoo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClassInterface<dyn IFoo, intercom::type_system::RawTypeSystem>
    for Foo
{
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().IFoo_Raw as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl
    intercom::attributes::ComClassInterface<
        dyn intercom::ISupportErrorInfo,
        intercom::type_system::AutomationTypeSystem,
    > for Foo
{
    #[inline(always)]
    fn offset() -> usize {
        0
    }
}
impl intercom::attributes::HasInterface<dyn intercom::IUnknown> for Foo {}
#[allow(non_snake_case)]
#[doc(hidden)]
struct __intercom_vtable_for_Foo {
    _ISupportErrorInfo: &'static <dyn intercom::ISupportErrorInfo as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable,
    Foo_Automation: &'static <<Foo as
    intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable,
    Foo_Raw: &'static <<Foo as intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable,
    IFoo_Automation: &'static <<dyn IFoo as
    intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable,
    IFoo_Raw: &'static <<dyn IFoo as
    intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable,
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_snake_case)]
impl ::core::clone::Clone for __intercom_vtable_for_Foo {
    #[inline]
    fn clone(&self) -> __intercom_vtable_for_Foo {
        {
            let _:
                    ::core::clone::AssertParamIsClone<&'static <dyn intercom::ISupportErrorInfo
                    as
                    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable>;
            let _:
                    ::core::clone::AssertParamIsClone<&'static <<Foo as
                    intercom::attributes::ComInterface>::TSelf as
                    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable>;
            let _:
                    ::core::clone::AssertParamIsClone<&'static <<Foo as
                    intercom::attributes::ComInterface>::TSelf as
                    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable>;
            let _:
                    ::core::clone::AssertParamIsClone<&'static <<dyn IFoo as
                    intercom::attributes::ComInterface>::TSelf as
                    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable>;
            let _:
                    ::core::clone::AssertParamIsClone<&'static <<dyn IFoo as
                    intercom::attributes::ComInterface>::TSelf as
                    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable>;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_snake_case)]
impl ::core::marker::Copy for __intercom_vtable_for_Foo {}
#[allow(non_snake_case)]
struct Static__intercom_vtable_for_Foo {
    Foo_Automation: <<Foo as intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable,
    Foo_Raw: <<Foo as intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable,
    IFoo_Automation: <<dyn IFoo as intercom::attributes::ComInterface>::TSelf
    as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable,
    IFoo_Raw: <<dyn IFoo as intercom::attributes::ComInterface>::TSelf as
    intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable,
}
#[allow(clippy::all)]
impl intercom::attributes::ComClass for Foo {
    type VTableList = __intercom_vtable_for_Foo;
    const VTABLE: Self::VTableList = __intercom_vtable_for_Foo {
        _ISupportErrorInfo:
            &<dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterfaceVTableFor<
                dyn intercom::ISupportErrorInfo,
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::VTABLE,
        Foo_Automation: &<Foo as intercom::attributes::ComInterfaceVTableFor<
            Foo,
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::VTABLE,
        Foo_Raw: &<Foo as intercom::attributes::ComInterfaceVTableFor<
            Foo,
            Foo,
            intercom::type_system::RawTypeSystem,
        >>::VTABLE,
        IFoo_Automation: &<dyn IFoo as intercom::attributes::ComInterfaceVTableFor<
            dyn IFoo,
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::VTABLE,
        IFoo_Raw: &<dyn IFoo as intercom::attributes::ComInterfaceVTableFor<
            dyn IFoo,
            Foo,
            intercom::type_system::RawTypeSystem,
        >>::VTABLE,
    };
    fn query_interface(
        vtables: &Self::VTableList,
        riid: intercom::REFIID,
    ) -> intercom::RawComResult<intercom::raw::RawComPtr> {
        if riid.is_null() {
            intercom::logging::error(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", "] ", "::query_interface(NULL)"],
                        &[
                            ::core::fmt::ArgumentV1::new_pointer(&vtables),
                            ::core::fmt::ArgumentV1::new_display(&"Foo"),
                        ],
                    ),
                )
            });
            return Err(intercom::raw::E_NOINTERFACE);
        }
        unsafe {
            let riid = &*riid;
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1_formatted(
                        &["[", "] ", "::query_interface(", ")"],
                        &[
                            ::core::fmt::ArgumentV1::new_pointer(&vtables),
                            ::core::fmt::ArgumentV1::new_display(&"Foo"),
                            ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                        ],
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: 0usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 1usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 2usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 2u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                        unsafe { ::core::fmt::UnsafeArg::new() },
                    ),
                )
            });
            Ok(if riid ==
                            <dyn intercom::IUnknown as
                                    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                        {
                        let ptr =
                            (&vtables._ISupportErrorInfo) as
                                        *const &<dyn intercom::ISupportErrorInfo as
                                        intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                                    as
                                    *mut &<dyn intercom::ISupportErrorInfo as
                                    intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                                as intercom::raw::RawComPtr;
                        intercom::logging::trace(|l|
                                l("testcrate",
                                    ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                    "::query_interface(", ") -> IUnknown [", "]"],
                                        &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                    ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                    ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                    ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                        &[::core::fmt::rt::v1::Argument {
                                                        position: 0usize,
                                                        format: ::core::fmt::rt::v1::FormatSpec {
                                                            fill: ' ',
                                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                            flags: 0u32,
                                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                                            width: ::core::fmt::rt::v1::Count::Implied,
                                                        },
                                                    },
                                                    ::core::fmt::rt::v1::Argument {
                                                        position: 1usize,
                                                        format: ::core::fmt::rt::v1::FormatSpec {
                                                            fill: ' ',
                                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                            flags: 0u32,
                                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                                            width: ::core::fmt::rt::v1::Count::Implied,
                                                        },
                                                    },
                                                    ::core::fmt::rt::v1::Argument {
                                                        position: 2usize,
                                                        format: ::core::fmt::rt::v1::FormatSpec {
                                                            fill: ' ',
                                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                            flags: 2u32,
                                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                                            width: ::core::fmt::rt::v1::Count::Implied,
                                                        },
                                                    },
                                                    ::core::fmt::rt::v1::Argument {
                                                        position: 3usize,
                                                        format: ::core::fmt::rt::v1::FormatSpec {
                                                            fill: ' ',
                                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                            flags: 0u32,
                                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                                            width: ::core::fmt::rt::v1::Count::Implied,
                                                        },
                                                    }], unsafe { ::core::fmt::UnsafeArg::new() })));
                        ptr
                    } else if riid ==
                           <dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                       {
                       let ptr =
                           (&vtables._ISupportErrorInfo) as
                                       *const &<dyn intercom::ISupportErrorInfo as
                                       intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                                   as
                                   *mut &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                               as intercom::raw::RawComPtr;
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> ISupportErrorInfo [", "]"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                   ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 3usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       ptr
                   } else if riid ==
                           <<Foo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                       {
                       let ptr =
                           &vtables.Foo_Automation as
                                       *const &<<Foo as intercom::attributes::ComInterface>::TSelf
                                       as
                                       intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                                   as
                                   *mut &<<Foo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                               as intercom::raw::RawComPtr;
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> ", " (", ") [", "]"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_display(&"Automation"),
                                                   ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 3usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 4usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 5usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       ptr
                   } else if riid ==
                           <<Foo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid()
                       {
                       let ptr =
                           &vtables.Foo_Raw as
                                       *const &<<Foo as intercom::attributes::ComInterface>::TSelf
                                       as
                                       intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable
                                   as
                                   *mut &<<Foo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable
                               as intercom::raw::RawComPtr;
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> ", " (", ") [", "]"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_display(&"Raw"),
                                                   ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 3usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 4usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 5usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       ptr
                   } else if riid ==
                           <<dyn IFoo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                       {
                       let ptr =
                           &vtables.IFoo_Automation as
                                       *const &<<dyn IFoo as
                                       intercom::attributes::ComInterface>::TSelf as
                                       intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                                   as
                                   *mut &<<dyn IFoo as
                                   intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::VTable
                               as intercom::raw::RawComPtr;
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> ", " (", ") [", "]"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                   ::core::fmt::ArgumentV1::new_display(&"IFoo"),
                                                   ::core::fmt::ArgumentV1::new_display(&"Automation"),
                                                   ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 3usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 4usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 5usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       ptr
                   } else if riid ==
                           <<dyn IFoo as intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid()
                       {
                       let ptr =
                           &vtables.IFoo_Raw as
                                       *const &<<dyn IFoo as
                                       intercom::attributes::ComInterface>::TSelf as
                                       intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable
                                   as
                                   *mut &<<dyn IFoo as
                                   intercom::attributes::ComInterface>::TSelf as
                                   intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::VTable
                               as intercom::raw::RawComPtr;
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> ", " (", ") [", "]"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid),
                                                   ::core::fmt::ArgumentV1::new_display(&"IFoo"),
                                                   ::core::fmt::ArgumentV1::new_display(&"Raw"),
                                                   ::core::fmt::ArgumentV1::new_pointer(&ptr)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 3usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 4usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 5usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       ptr
                   } else {
                       intercom::logging::trace(|l|
                               l("testcrate",
                                   ::core::fmt::Arguments::new_v1_formatted(&["[", "] ",
                                                   "::query_interface(", ") -> E_NOINTERFACE"],
                                       &[::core::fmt::ArgumentV1::new_pointer(&vtables),
                                                   ::core::fmt::ArgumentV1::new_display(&"Foo"),
                                                   ::core::fmt::ArgumentV1::new_upper_hex(&riid)],
                                       &[::core::fmt::rt::v1::Argument {
                                                       position: 0usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 1usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 0u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   },
                                                   ::core::fmt::rt::v1::Argument {
                                                       position: 2usize,
                                                       format: ::core::fmt::rt::v1::FormatSpec {
                                                           fill: ' ',
                                                           align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                           flags: 2u32,
                                                           precision: ::core::fmt::rt::v1::Count::Implied,
                                                           width: ::core::fmt::rt::v1::Count::Implied,
                                                       },
                                                   }], unsafe { ::core::fmt::UnsafeArg::new() })));
                       return Err(intercom::raw::E_NOINTERFACE)
                   })
        }
    }
    fn interface_supports_error_info(riid: intercom::REFIID) -> bool {
        if riid.is_null() {
            return false;
        }
        unsafe {
            let riid = &*riid;
            if riid ==
                        <<Foo as intercom::attributes::ComInterface>::TSelf as
                                intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                    {
                    true
                } else if riid ==
                       <<Foo as intercom::attributes::ComInterface>::TSelf as
                               intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid()
                   {
                   true
               } else if riid ==
                       <<dyn IFoo as intercom::attributes::ComInterface>::TSelf as
                               intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid()
                   {
                   true
               } else if riid ==
                       <<dyn IFoo as intercom::attributes::ComInterface>::TSelf as
                               intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid()
                   {
                   true
               } else { false }
        }
    }
}
#[allow(non_upper_case_globals)]
#[doc = "`Foo` class ID."]
pub const CLSID_Foo: intercom::CLSID = intercom::GUID {
    data1: 0u32,
    data2: 0u16,
    data3: 0u16,
    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
};
impl intercom::attributes::ComClassTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let mut r =
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([intercom::typelib::TypeInfo::Class(intercom::ComBox::new(intercom::typelib::CoClass::__new("Foo".into(),
                                        intercom::GUID {
                                            data1: 0u32,
                                            data2: 0u16,
                                            data3: 0u16,
                                            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                                        },
                                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([intercom::typelib::InterfaceRef {
                                                            name: "Foo".into(),
                                                            iid_automation: <<Foo as
                                                                        intercom::attributes::ComInterface>::TSelf as
                                                                        intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid().clone(),
                                                            iid_raw: <<Foo as intercom::attributes::ComInterface>::TSelf
                                                                        as
                                                                        intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid().clone(),
                                                        },
                                                        intercom::typelib::InterfaceRef {
                                                            name: "IFoo".into(),
                                                            iid_automation: <<dyn IFoo as
                                                                        intercom::attributes::ComInterface>::TSelf as
                                                                        intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>>::iid().clone(),
                                                            iid_raw: <<dyn IFoo as
                                                                        intercom::attributes::ComInterface>::TSelf as
                                                                        intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem>>::iid().clone(),
                                                        }])))))]));
        r.extend(<Foo as intercom::attributes::ComInterfaceTypeInfo>::gather_type_info());
        r.extend(<dyn IFoo as intercom::attributes::ComInterfaceTypeInfo>::gather_type_info());
        r
    }
}
impl Foo {
    pub fn struct_method(&self) {}
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_struct_method_Automation(
    self_vtable: intercom::raw::RawComPtr,
) -> () {
    let offset = <Foo as intercom::attributes::ComClassInterface<
        Foo,
        intercom::type_system::AutomationTypeSystem,
    >>::offset();
    let self_combox = (self_vtable as usize - offset) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<Foo>()),
                    ::core::fmt::ArgumentV1::new_display(&"struct_method"),
                ],
            ),
        )
    });
    let self_struct = &**self_combox;
    let __result = self_struct.struct_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<Foo>()),
                    ::core::fmt::ArgumentV1::new_display(&"struct_method"),
                ],
            ),
        )
    });
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
pub struct __FooAutomationVTable {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub struct_method: unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::clone::Clone for __FooAutomationVTable {
    #[inline]
    fn clone(&self) -> __FooAutomationVTable {
        {
            let _: ::core::clone::AssertParamIsClone<
                <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable,
            >;
            let _: ::core::clone::AssertParamIsClone<
                unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
            >;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::marker::Copy for __FooAutomationVTable {}
#[allow(unused)]
impl<I, S>
    intercom::attributes::ComInterfaceVTableFor<I, S, intercom::type_system::AutomationTypeSystem>
    for Foo
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::AutomationTypeSystem>
        + intercom::attributes::ComClass,
{
    const VTABLE: __FooAutomationVTable = __FooAutomationVTable {
        __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVTableFor<
            I,
            S,
            intercom::type_system::AutomationTypeSystem,
        >>::VTABLE,
        struct_method: __Foo_struct_method_Automation,
    };
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterfaceVariant<intercom::type_system::AutomationTypeSystem>
    for Foo
{
    type VTable = __FooAutomationVTable;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8],
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_struct_method_Raw(self_vtable: intercom::raw::RawComPtr) -> () {
    let offset = <Foo as intercom::attributes::ComClassInterface<
        Foo,
        intercom::type_system::RawTypeSystem,
    >>::offset();
    let self_combox = (self_vtable as usize - offset) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<Foo>()),
                    ::core::fmt::ArgumentV1::new_display(&"struct_method"),
                ],
            ),
        )
    });
    let self_struct = &**self_combox;
    let __result = self_struct.struct_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &[
                    ::core::fmt::ArgumentV1::new_pointer(&self_combox),
                    ::core::fmt::ArgumentV1::new_pointer(&self_vtable),
                    ::core::fmt::ArgumentV1::new_display(&std::any::type_name::<Foo>()),
                    ::core::fmt::ArgumentV1::new_display(&"struct_method"),
                ],
            ),
        )
    });
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
pub struct __FooRawVTable {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
    pub struct_method: unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::clone::Clone for __FooRawVTable {
    #[inline]
    fn clone(&self) -> __FooRawVTable {
        {
            let _: ::core::clone::AssertParamIsClone<
                <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::RawTypeSystem,
                >>::VTable,
            >;
            let _: ::core::clone::AssertParamIsClone<
                unsafe extern "system" fn(self_vtable: intercom::raw::RawComPtr) -> (),
            >;
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
impl ::core::marker::Copy for __FooRawVTable {}
#[allow(unused)]
impl<I, S> intercom::attributes::ComInterfaceVTableFor<I, S, intercom::type_system::RawTypeSystem>
    for Foo
where
    I: ?Sized,
    S: intercom::attributes::ComClassInterface<I, intercom::type_system::RawTypeSystem>
        + intercom::attributes::ComClass,
{
    const VTABLE: __FooRawVTable = __FooRawVTable {
        __base: <dyn intercom::IUnknown as intercom::attributes::ComInterfaceVTableFor<
            I,
            S,
            intercom::type_system::RawTypeSystem,
        >>::VTABLE,
        struct_method: __Foo_struct_method_Raw,
    };
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterfaceVariant<intercom::type_system::RawTypeSystem> for Foo {
    type VTable = __FooRawVTable;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 3u8],
        }
    }
}
impl intercom::attributes::ComInterface for Foo {
    type TSelf = Foo;
    #[doc = "Returns the IID of the requested interface."]
    fn iid_ts<TS: intercom::type_system::TypeSystem>() -> &'static intercom::IID
    where
        Self: intercom::attributes::ComInterfaceVariant<TS>,
    {
        <Self as intercom::attributes::ComInterfaceVariant<TS>>::iid()
    }
    fn iid(ts: intercom::type_system::TypeSystemName) -> Option<&'static intercom::IID> {
        match ts {
            intercom::type_system::TypeSystemName::Automation => {
                Some(<Self as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid())
            }
            intercom::type_system::TypeSystemName::Raw => {
                Some(<Self as intercom::attributes::ComInterfaceVariant<
                    intercom::type_system::RawTypeSystem,
                >>::iid())
            }
        }
    }
    fn deref(com_itf: &intercom::ComItf<Foo>) -> &Foo {
        let some_iunk: &intercom::ComItf<dyn intercom::interfaces::RawIUnknown> =
            com_itf.as_raw_iunknown();
        let iunknown_iid =
            <dyn intercom::IUnknown>::iid(intercom::type_system::TypeSystemName::Automation)
                .expect("IUnknown must have Automation IID");
        let primary_iunk = some_iunk
            .query_interface(iunknown_iid)
            .expect("All types must implement IUnknown");
        let combox: *mut intercom::ComBoxData<Foo> = primary_iunk as *mut intercom::ComBoxData<Foo>;
        unsafe {
            intercom::ComBoxData::release(combox);
            use std::ops::Deref;
            (*combox).deref()
        }
    }
}
impl intercom::type_system::ForeignType for Foo {
    #[doc = r" The name of the type."]
    fn type_name() -> &'static str {
        "Foo"
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
impl intercom::attributes::ComInterfaceTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let variants = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                    ts: intercom::type_system::TypeSystemName::Automation,
                    iid: intercom::GUID {
                        data1: 0u32,
                        data2: 0u16,
                        data3: 0u16,
                        data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8],
                    },
                    methods: <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([intercom::ComBox::new(
                            intercom::typelib::Method {
                                name: "struct_method".into(),
                                return_type: intercom::typelib::Arg {
                                    name: "".into(),
                                    ty: "void".into(),
                                    indirection_level: 0,
                                    direction: intercom::typelib::Direction::Return,
                                },
                                parameters: ::alloc::vec::Vec::new(),
                            },
                        )]),
                    ),
                }),
                intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                    ts: intercom::type_system::TypeSystemName::Raw,
                    iid: intercom::GUID {
                        data1: 0u32,
                        data2: 0u16,
                        data3: 0u16,
                        data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 3u8],
                    },
                    methods: <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([intercom::ComBox::new(
                            intercom::typelib::Method {
                                name: "struct_method".into(),
                                return_type: intercom::typelib::Arg {
                                    name: "".into(),
                                    ty: "void".into(),
                                    indirection_level: 0,
                                    direction: intercom::typelib::Direction::Return,
                                },
                                parameters: ::alloc::vec::Vec::new(),
                            },
                        )]),
                    ),
                }),
            ]),
        );
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([intercom::typelib::TypeInfo::Interface(
                intercom::ComBox::new(intercom::typelib::Interface {
                    name: "Foo".into(),
                    variants,
                    options: intercom::typelib::InterfaceOptions {
                        class_impl_interface: true,
                        ..Default::default()
                    },
                }),
            )]),
        )
    }
}
impl IFoo for Foo {
    fn trait_method(&self) {}
}

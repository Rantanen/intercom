#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate intercom;
use intercom::*;
use std::mem::MaybeUninit;

// We need the IID and Vtbl to ensure this compiles.
//
// Normally these are provided by the [com_interface].
#[allow(non_camel_case_types)]
struct __Foo_AutomationVtbl;
const IID_Foo_Automation: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

#[allow(non_camel_case_types)]
struct __Foo_RawVtbl;
const IID_Foo_Raw: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

fn get_intercom_interface_info_for_Foo() -> Vec<intercom::typelib::TypeInfo> {
    unsafe { MaybeUninit::uninit().assume_init() }
}

pub struct Foo;
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Raw as *const _ as usize }
    }
}
#[allow(non_upper_case_globals)]
impl
    intercom::attributes::ComImpl<
        intercom::ISupportErrorInfo,
        intercom::type_system::AutomationTypeSystem,
    > for Foo
{
    fn vtable()
     ->
         &'static <dyn intercom::ISupportErrorInfo as
intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable{
        type T = <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type Vtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                Vtbl {
                    query_interface: intercom::ComBoxData::<Foo>::query_interface_ptr,
                    add_ref: intercom::ComBoxData::<Foo>::add_ref_ptr,
                    release: intercom::ComBoxData::<Foo>::release_ptr,
                }
            },
            interface_supports_error_info:
                intercom::ComBoxData::<Foo>::interface_supports_error_info_ptr,
        }
    }
}
impl intercom::HasInterface<intercom::IUnknown> for Foo {}
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct __intercom_vtable_for_Foo {
    _ISupportErrorInfo:
        &'static <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable,
    Foo_Automation: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    Foo_Raw: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
}
#[allow(clippy::all)]
impl intercom::CoClass for Foo {
    type VTableList = __intercom_vtable_for_Foo;
    fn create_vtable_list() -> Self::VTableList {
        __intercom_vtable_for_Foo {
            _ISupportErrorInfo: <Foo as intercom::attributes::ComImpl<
                dyn intercom::ISupportErrorInfo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Automation: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Raw: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::RawTypeSystem,
            >>::vtable(),
        }
    }
    fn query_interface(
        vtables: &Self::VTableList,
        riid: intercom::REFIID,
    ) -> intercom::RawComResult<intercom::RawComPtr> {
        if riid.is_null() {
            intercom::logging::error(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", "] ", "::query_interface(NULL)"],
                        &match (&vtables, &"Foo") {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            return Err(intercom::raw::E_NOINTERFACE);
        }
        unsafe {
            let riid = &*riid;
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1_formatted(
                        &["[", "] ", "::query_interface(", ")"],
                        &match (&vtables, &"Foo", &riid) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::UpperHex::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(0usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(1usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(2usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 2u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ),
                )
            });
            Ok(
                if riid
                    == <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> IUnknown [", "]"],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &[
                                    "[",
                                    "] ",
                                    "::query_interface(",
                                    ") -> ISupportErrorInfo [",
                                    "]",
                                ],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Automation
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Automation", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::RawTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Raw
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Raw", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else {
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> E_NOINTERFACE"],
                                &match (&vtables, &"Foo", &riid) {
                                    (arg0, arg1, arg2) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    return Err(intercom::raw::E_NOINTERFACE);
                },
            )
        }
    }
    fn interface_supports_error_info(riid: intercom::REFIID) -> bool {
        if riid.is_null() {
            return false;
        }
        unsafe {
            let riid = &*riid;
            if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid()
            {
                true
            } else {
                false
            }
        }
    }
}
#[allow(non_upper_case_globals)]
#[doc = "`Foo` class ID."]
pub const CLSID_Foo: intercom::CLSID = intercom::GUID {
    data1: 0u32,
    data2: 0u16,
    data3: 0u16,
    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
};
impl intercom::attributes::HasTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let mut r =




            // Should be VARIANT_BOOL in Automation interface.

            <[_]>::into_vec(box
                                [intercom::typelib::TypeInfo::Class(intercom::ComBox::new(intercom::typelib::CoClass::__new("Foo".into(),
                                                                                                                            intercom::GUID{data1:
                                                                                                                                               0u32,
                                                                                                                                           data2:
                                                                                                                                               0u16,
                                                                                                                                           data3:
                                                                                                                                               0u16,
                                                                                                                                           data4:
                                                                                                                                               [0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8],},
                                                                                                                            <[_]>::into_vec(box
                                                                                                                                                [intercom::typelib::InterfaceRef{name:
                                                                                                                                                                                     "Foo".into(),
                                                                                                                                                                                 iid_automation:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::iid().clone(),
                                                                                                                                                                                 iid_raw:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::iid().clone(),}]))))]);
        r.extend(<Foo as intercom::attributes::InterfaceHasTypeInfo>::gather_type_info());
        r
    }
}
impl Foo {
    fn static_method(a: u16, b: i16) {}
    fn simple_method(&self) {}
    fn arg_method(&self, a: u16) {}
    fn simple_result_method(&self) -> u16 {
        0
    }
    fn com_result_method(&self) -> ComResult<u16> {
        Ok(0)
    }
    fn rust_result_method(&self) -> Result<u16, i32> {
        Ok(0)
    }
    fn tuple_result_method(&self) -> Result<(u8, u16, u32), i32> {
        Ok(0)
    }
    fn string_method(&self, input: String) -> String {
        input
    }
    fn string_result_method(&self, input: String) -> ComResult<String> {
        Ok(input)
    }
    fn complete_method(&mut self, a: u16, b: i16) -> ComResult<bool> {
        Ok(true)
    }
    fn bool_method(&self, input: bool) -> ComResult<bool> {
        Ok(input)
    }
    fn variant_method(&self, input: Variant) -> ComResult<Variant> {
        Ok(input)
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_query_interface_Automation(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_add_ref_Automation(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_release_Automation(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_simple_method_Automation(
    self_vtable: intercom::RawComPtr,
) -> () {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.simple_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_arg_method_Automation(
    self_vtable: intercom::RawComPtr,
    a: <u16 as intercom::type_system::InfallibleExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> () {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.arg_method(<u16 as intercom::type_system::InfallibleExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::from_foreign_parameter(a));
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_simple_result_method_Automation(
    self_vtable: intercom::RawComPtr,
) -> <u16 as intercom::type_system::InfallibleExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.simple_result_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    <u16 as intercom::type_system::InfallibleExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::into_foreign_output(__result)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_com_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_rust_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_tuple_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out1: *mut <u8 as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    __out2: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    __out3: *mut <u32 as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = <u8 as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    *__out2 = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v2)?;
                    *__out3 = <u32 as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v3)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_string_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <String as intercom::type_system::InfallibleExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <String as intercom::type_system::InfallibleExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result =
        self_struct.string_method(<String as intercom::type_system::InfallibleExternInput<
            intercom::type_system::AutomationTypeSystem,
        >>::from_foreign_parameter(input));
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    <String as intercom::type_system::InfallibleExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::into_foreign_output(__result)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_string_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <String as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    __out: *mut <String as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result =
            self_struct.string_result_method(<String as intercom::type_system::ExternInput<
                intercom::type_system::AutomationTypeSystem,
            >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <String as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_complete_method_Automation(
    self_vtable: intercom::RawComPtr,
    a:
                                                                   <u16 as
                                                                   intercom::type_system::ExternInput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
    b:
                                                                   <i16 as
                                                                   intercom::type_system::ExternInput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
    __out: *mut <bool as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &mut Foo = &mut **self_combox;
        let __result = self_struct.complete_method(
            <u16 as intercom::type_system::ExternInput<
                intercom::type_system::AutomationTypeSystem,
            >>::from_foreign_parameter(a)?,
            <i16 as intercom::type_system::ExternInput<
                intercom::type_system::AutomationTypeSystem,
            >>::from_foreign_parameter(b)?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <bool as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_bool_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <bool as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    __out: *mut <bool as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.bool_method(<bool as intercom::type_system::ExternInput<
            intercom::type_system::AutomationTypeSystem,
        >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <bool as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_variant_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <Variant as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    __out: *mut <Variant as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::AutomationTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result =
            self_struct.variant_method(<Variant as intercom::type_system::ExternInput<
                intercom::type_system::AutomationTypeSystem,
            >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <Variant as intercom::type_system::ExternOutput<
                        intercom::type_system::AutomationTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    fn vtable() -> &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable {
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_query_interface_Automation,
                    add_ref: __Foo_Foo_add_ref_Automation,
                    release: __Foo_Foo_release_Automation,
                }
            },
            simple_method: __Foo_Foo_simple_method_Automation,
            arg_method: __Foo_Foo_arg_method_Automation,
            simple_result_method: __Foo_Foo_simple_result_method_Automation,
            com_result_method: __Foo_Foo_com_result_method_Automation,
            rust_result_method: __Foo_Foo_rust_result_method_Automation,
            tuple_result_method: __Foo_Foo_tuple_result_method_Automation,
            string_method: __Foo_Foo_string_method_Automation,
            string_result_method: __Foo_Foo_string_result_method_Automation,
            complete_method: __Foo_Foo_complete_method_Automation,
            bool_method: __Foo_Foo_bool_method_Automation,
            variant_method: __Foo_Foo_variant_method_Automation,
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_query_interface_Raw(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_add_ref_Raw(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_release_Raw(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_simple_method_Raw(self_vtable: intercom::RawComPtr) -> () {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.simple_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_arg_method_Raw(
    self_vtable: intercom::RawComPtr,
    a: <u16 as intercom::type_system::InfallibleExternInput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> () {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.arg_method(<u16 as intercom::type_system::InfallibleExternInput<
        intercom::type_system::RawTypeSystem,
    >>::from_foreign_parameter(a));
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_simple_result_method_Raw(self_vtable:
                                                                 intercom::RawComPtr)
 ->
     <u16 as
intercom::type_system::InfallibleExternOutput<intercom::type_system::RawTypeSystem>>::ForeignType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result = self_struct.simple_result_method();
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    <u16 as
        intercom::type_system::InfallibleExternOutput<intercom::type_system::RawTypeSystem>>::into_foreign_output(__result)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_com_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_rust_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_tuple_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out1: *mut <u8 as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
    __out2: *mut <u16 as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
    __out3: *mut <u32 as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = <u8 as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    *__out2 = <u16 as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v2)?;
                    *__out3 = <u32 as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v3)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_string_method_Raw(self_vtable:
                                                          intercom::RawComPtr,
                                                      input:
                                                          <String as
                                                          intercom::type_system::InfallibleExternInput<intercom::type_system::RawTypeSystem>>::ForeignType)
 ->
     <String as
intercom::type_system::InfallibleExternOutput<intercom::type_system::RawTypeSystem>>::ForeignType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::"],
                &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    let self_struct: &Foo = &**self_combox;
    let __result =
        self_struct.string_method(<String as intercom::type_system::InfallibleExternInput<
            intercom::type_system::RawTypeSystem,
        >>::from_foreign_parameter(input));
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::", ", OK"],
                &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                    (arg0, arg1, arg2, arg3) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    <String as intercom::type_system::InfallibleExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::into_foreign_output(__result)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_string_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                                 <String as
                                                                 intercom::type_system::ExternInput<intercom::type_system::RawTypeSystem>>::ForeignType,
    __out: *mut <String as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct
            .string_result_method(<String as intercom::type_system::ExternInput<
            intercom::type_system::RawTypeSystem,
        >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <String as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_complete_method_Raw(
    self_vtable: intercom::RawComPtr,
    a:
                                                            <u16 as
                                                            intercom::type_system::ExternInput<intercom::type_system::RawTypeSystem>>::ForeignType,
    b:
                                                            <i16 as
                                                            intercom::type_system::ExternInput<intercom::type_system::RawTypeSystem>>::ForeignType,
    __out: *mut <bool as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &mut Foo = &mut **self_combox;
        let __result =
            self_struct.complete_method(
                <u16 as intercom::type_system::ExternInput<
                    intercom::type_system::RawTypeSystem,
                >>::from_foreign_parameter(a)?,
                <i16 as intercom::type_system::ExternInput<
                    intercom::type_system::RawTypeSystem,
                >>::from_foreign_parameter(b)?,
            );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <bool as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_bool_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                        <bool as
                                                        intercom::type_system::ExternInput<intercom::type_system::RawTypeSystem>>::ForeignType,
    __out: *mut <bool as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.bool_method(<bool as intercom::type_system::ExternInput<
            intercom::type_system::RawTypeSystem,
        >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <bool as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_variant_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                           <Variant as
                                                           intercom::type_system::ExternInput<intercom::type_system::RawTypeSystem>>::ForeignType,
    __out: *mut <Variant as intercom::type_system::ExternOutput<
        intercom::type_system::RawTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::RawTypeSystem,
>>::ForeignType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
            intercom::type_system::RawTypeSystem,
        >>::ForeignType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result =
            self_struct.variant_method(<Variant as intercom::type_system::ExternInput<
                intercom::type_system::RawTypeSystem,
            >>::from_foreign_parameter(input)?);
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = <Variant as intercom::type_system::ExternOutput<
                        intercom::type_system::RawTypeSystem,
                    >>::into_foreign_output(v1)?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternOutput<
                intercom::type_system::RawTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::RawTypeSystem> for Foo {
    fn vtable()
     ->
         &'static <Foo as
intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::VTable{
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::RawTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_query_interface_Raw,
                    add_ref: __Foo_Foo_add_ref_Raw,
                    release: __Foo_Foo_release_Raw,
                }
            },
            simple_method: __Foo_Foo_simple_method_Raw,
            arg_method: __Foo_Foo_arg_method_Raw,
            simple_result_method: __Foo_Foo_simple_result_method_Raw,
            com_result_method: __Foo_Foo_com_result_method_Raw,
            rust_result_method: __Foo_Foo_rust_result_method_Raw,
            tuple_result_method: __Foo_Foo_tuple_result_method_Raw,
            string_method: __Foo_Foo_string_method_Raw,
            string_result_method: __Foo_Foo_string_result_method_Raw,
            complete_method: __Foo_Foo_complete_method_Raw,
            bool_method: __Foo_Foo_bool_method_Raw,
            variant_method: __Foo_Foo_variant_method_Raw,
        }
    }
}
impl intercom::HasInterface<Foo> for Foo {}
